[comment encoding = Cp1252 /]
[module generateDaoTestUtilJava('http://www.eclipse.org/uml2/3.0.0/UML')/]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::dao::common::daoPathUtil /]
[import org::acceleo::module::pim::uml21::gen::java::common::common /]
[import org::acceleo::module::pim::uml21::gen::java::spring::common /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::common::pathUtil /]
[import org::acceleo::module::pim::uml21::gen::java::common::structure /]
[import org::acceleo::module::pim::uml21::gen::java::common::requests /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::common::requests /]
[import org::acceleo::module::pim::uml21::gen::java::common::dataTypes /]
[import org::acceleo::module::pim::uml21::gen::java::common::compositeUtil /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::dao::common::daoUtil /]
[import org::acceleo::module::pim::uml21::services::uml2services /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::dao::common::daoCommon /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::common::stringUtil /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::main::common::mainCommon /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::build::common::entityUtil /]

[template public generateDaoTestUtilJava(aModel : Model)]
[file (aModel.generateProjectFolder().concat(aModel.pathToTestJava()).concat('/tests/integration/DaoTestUtil.java'), false, 'UTF-8')]
package tests.integration;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Collection;
import javax.sql.DataSource;
import java.text.SimpleDateFormat;
import java.text.ParseException;
import java.util.Calendar;
import java.util.Date;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
	[for (anEntity : Class | aModel.eAllContents(Class)->select(aClass:Class|aClass.isEntity()))]
		[if (anEntity.generateJavaPackage() <> 'tests.integration')]
			[if (not anEntity.hasEntityParent())]
import [if (anEntity.generateJavaPackage().size()>0)][anEntity.generateJavaPackage()/].[/if][anEntity.name.toUpperFirst()/];
			[/if]
import [if (anEntity.generateJavaPackage().size()>0)][anEntity.generateJavaPackage()/].[/if][anEntity.name.toUpperFirst()/]Impl;
		[/if]
	[/for]
	[let entities : Set(Class) = aModel.eAllContents(Class)->select(aClass:Class|aClass.isEntity())->asSet()]
		[let enumTypes : Set(Type) = entities.ownedAttribute.type->filter(Enumeration)->union(entities.ownedOperation.ownedParameter.type->filter(Enumeration))->asSet() ]
			[for (enumType : Type | enumTypes)]
		[if (enumType.generateJavaPackage() <> 'tests.integration')]
import [if (enumType.generateJavaPackage().size()>0)][enumType.generateJavaPackage()/].[/if][enumType.name.toUpperFirst()/];
		[/if]
			[/for]
		[/let]
	[/let]

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Collection;


public final class DaoTestUtil {

	private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");

	private DaoTestUtil() {
	}
	
	public static Date increaseOneDay(Date firstDate) {
		Calendar calendar =  Calendar.getInstance();
		calendar.setTime(firstDate);
		calendar.set(Calendar.DATE, calendar.get(Calendar.DATE)+1);
		return calendar.getTime(); 
	}

	public static String createStringFieldValue(String fieldName, long index) {
		return fieldName+index; 
	}
	
	public static boolean createBooleanFieldValue(String fieldName, long index) {
		return index % 2==1; 
	}

	public static int createNumberFieldValue(String fieldName, long index) {
		return Long.valueOf(index).intValue(); 
	}
	
	public static Date createDateFieldValue(String fieldName, long index) {
		try {
			return DaoTestUtil.dateFormat.parse("2012/01/"+index);
        } catch (ParseException ex) {
			throw new RuntimeException(ex);
        }
		
	}
	
	[for (anEnumeration : Enumeration | aModel.eAllContents(Enumeration))]
	public static [anEnumeration.name.toUpperFirst()/] create[anEnumeration.name.toUpperFirst()/]Value(String fieldName, long index) {
		switch(Long.valueOf(index%[anEnumeration.ownedLiteral->size()/]).intValue()) {
			[for (anEnumeration.ownedLiteral)]
			case [i-1/]: return [anEnumeration.name.toUpperFirst()/].[self.name/];
			[/for]
			default: throw new RuntimeException("Unknown problem");
		}
	}
	[/for]
	[aModel.eAllContents(Class)->select(aClass:Class|aClass.isEntity()).createObjectFuction()/]
	[comment][for (anEntity : Class | aModel.eAllContents(Class)->select(aClass:Class|aClass.isEntity()))]
			[for (anOppositeProp : Property | anEntity.getOppositeAttributes(false)->select(aProperty:Property|not aProperty.isPK() and not aProperty.type.isSimpleType() and aProperty.upper<=1 and aProperty.upper>=1))]
	public static [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] create[anEntity.name.toUpperFirst()/]Object(long index) {
		Map<String, Long> childIndexMap = new HashMap<String, Long>();
		Long childIndex = null;	
	    [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] [anEntity.name.toLowerFirst()/] = new [anEntity.name.toUpperFirst()/]Impl();
		[let classStructures : Sequence(Class) = anEntity.getAllEntityParents()->including(anEntity)]
			[for (aStructureClass : Class | classStructures)]
				[if (aStructureClass.ownedAttribute->notEmpty())]
					[for (aProperty : Property | aStructureClass.ownedAttribute)]
	    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/]([aProperty.type.generateSampleParameterValue(aProperty.name, 'index')/]);
					[/for]
					[for (aProperty : Property | aStructureClass.getOppositeAttributes()->select(aField:Property | aField.lower=1))]
						[if (aProperty.type.isJavaPrimitiveType())]
	    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/]([aProperty.type.generateSampleParameterValue(aProperty.name, 'index')/]);
						[elseif (aProperty.type.oclIsTypeOf(Class) and aProperty.type.oclAsType(Class).isEntity())]
		childIndex = childIndexMap.get([anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if].class.getName()); 
		if(childIndex == null) {
			childIndex = Long.valueOf(index);
		} else {
			childIndex = Long.valueOf(childIndex.longValue() + 1);
		}
		childIndexMap.put([anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if].class.getName(), childIndex);
							[if (aProperty.upper = 1)]
	    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/](DaoTestUtil.create[aProperty.type.name.toUpperFirst()/]Object(childIndex));
							[else]
								[if (aProperty.isOrdered)]
	    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/](Arrays.asList(DaoTestUtil.create[aProperty.type.name.toUpperFirst()/]Object(childIndex)));
								[/if]
								[if (anEntity.getMultiplicity()->select(aMultiplicityElement:MultiplicityElement|aMultiplicityElement.isUnique)->notEmpty())]
	    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/](new HashSet(Arrays.asList(DaoTestUtil.create[aProperty.type.name.toUpperFirst()/]Object(childIndex))));
								[/if]
								[if (anEntity.getMultiplicity()->select(aMultiplicityElement:MultiplicityElement|not (aMultiplicityElement.isOrdered) and not (aMultiplicityElement.isUnique))->notEmpty())]
	    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/](Arrays.asList(DaoTestUtil.create[aProperty.type.name.toUpperFirst()/]Object(childIndex)));
								[/if]
							[/if]
						[/if]						
					[/for]
				[/if]
			[/for]
		[/let]
		[anEntity.name.toUpperFirst()/]DaoTest.get[anEntity.name.toUpperFirst()/]Dao().create([anEntity.name.toLowerFirst()/]);
		return [anEntity.name.toLowerFirst()/];
	}
			[/for]
	[/for][/comment]

}
[/file]
[/template]
[template public createObjectFuction(anEntity : Class)]
	[let refProperties : Sequence(Property) = anEntity.getAllEntityParents()->including(anEntity).getOppositeAttributes(false)->select(aProperty:Property|not aProperty.isPK()  and aProperty.isNavigable() and not aProperty.type.isSimpleType() and aProperty.upper<=1 and aProperty.upper>=0)->asSequence()]
public static [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] create[anEntity.name.toUpperFirst()/]Object(long index) {
		[if (refProperties->notEmpty())]
			[let anOppositeProp : Property = refProperties->first()]
	return DaoTestUtil.create[anEntity.name.toUpperFirst()/]ObjectRefTo[anOppositeProp.type.name.toUpperFirst()/]OfField[anOppositeProp.type.oclAsType(Class).getAllEntityParents()->including(anOppositeProp.type.oclAsType(Class)).getAssociations()->select(anAss:Association|anAss.memberEnd->exists(aMemberEnd:Property|aMemberEnd=anOppositeProp)).memberEnd->select(aMemberEnd:Property|aMemberEnd<>anOppositeProp)->asSequence()->first().name.toUpperFirst()/](index, null);
			[/let]
		[else]
	Map<String, Long> childIndexMap = new HashMap<String, Long>();
	Long childIndex = null;	
    [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] [anEntity.name.toLowerFirst()/] = new [anEntity.name.toUpperFirst()/]Impl();
			[let classStructures : Sequence(Class) = anEntity.getAllEntityParents()->including(anEntity)]
				[for (aProperty : Property | classStructures.ownedAttribute)]
					[if (aProperty.type.isSimpleType())]
    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/]([aProperty.type.generateSampleParameterValue(aProperty.name, 'index')/]);
					[else]
						--[aProperty.type.name/]--
						[comment][let aRefProperty : Property =  classStructures.getAssociations()->select(anAss:Association|anAss.memberEnd->exists(aMemberEnd:Property|aMemberEnd=aProperty)).memberEnd->select(aMemberEnd:Property|aMemberEnd<>aProperty)->asSequence()->first()]
    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/](DaoTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[aRefProperty.type.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]));
						[/let][/comment]								
					[/if]						
				[/for]
			[/let]
	[anEntity.name.toUpperFirst()/]DaoTest.get[anEntity.name.toUpperFirst()/]Dao().create([anEntity.name.toLowerFirst()/]);
	return [anEntity.name.toLowerFirst()/];	
		[/if]
}
//-------------
		[if (refProperties->notEmpty())]
			[for (refProperty : Property | refProperties)]
[anEntity.createObjectFuction(refProperty, refProperty.type.oclAsType(Class).getAllEntityParents()->including(refProperty.type.oclAsType(Class)).getAssociations()->select(anAss:Association|anAss.memberEnd->exists(aMemberEnd:Property|aMemberEnd=refProperty)).memberEnd->select(aMemberEnd:Property|aMemberEnd<>refProperty)->first())/]
			[/for]
		[/if]
//-------------
	[/let]
[/template]

[template public createObjectFuction(anEntity : Class, refProperty : Property, ownedProperty : Property)]
[comment][for (anOppositeProp : Property | anEntity.getAllEntityParents()->including(anEntity).getOppositeAttributes(false)->select(aProperty:Property|not aProperty.isPK() and not aProperty.type.isSimpleType() and aProperty.upper<=1 and aProperty.upper>=0))][/comment]
public static [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] create[anEntity.name.toUpperFirst()/]ObjectRefTo[refProperty.type.name.toUpperFirst()/]OfField[refProperty.name.toUpperFirst()/](long index, [refProperty.type.name.toUpperFirst()/] [refProperty.type.name.toLowerFirst()/]) {
	Map<String, Long> childIndexMap = new HashMap<String, Long>();
	Long childIndex = null;	
    [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] [anEntity.name.toLowerFirst()/] = new [anEntity.name.toUpperFirst()/]Impl();
	[let classStructures : Sequence(Class) = anEntity.getAllEntityParents()->including(anEntity)]
		[for (aProperty : Property | classStructures.ownedAttribute)]
			[if (aProperty.type.isSimpleType())]
    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/]([aProperty.type.generateSampleParameterValue(aProperty.name, 'index')/]);
			[else]
						[comment][let aRefProperty : Property = aStructureClass.getAssociations()->select(anAss : Association|anAss.memberEnd->exists(aMember : Property | aMember=aProperty)).memberEnd->select(aMember : Property | aMember<>aProperty)->asSequence()->first()]
							[if (aRefProperty.upper >= 0 and aRefProperty.upper <= 1)]
	[refProperty.type.name.toLowerFirst()/].set[aRefProperty.name.toUpperFirst()/](DaoTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]));
							[elseif (aRefProperty.isOrdered)]
	[refProperty.type.name.toLowerFirst()/].set[aRefProperty.name.toUpperFirst()/](Arrays.asList(DaoTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/])));
							[elseif (aRefProperty.isUnique)]
	[refProperty.type.name.toLowerFirst()/].set[aRefProperty.name.toUpperFirst()/](new HashSet(Arrays.asList(DaoTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]))));
							[elseif (not aRefProperty.isOrdered and not aRefProperty.isUnique)]
	[refProperty.type.name.toLowerFirst()/].set[aRefProperty.name.toUpperFirst()/](Arrays.asList(DaoTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/])));
							[/if]
						[/let][/comment]
			[/if]								
		[/for]
		==[classStructures.getOppositeAttributes(false)->select(aField:Property | aField.lower=1)->size()/]==
		[for (aRefProperty : Property | classStructures.getOppositeAttributes(false)->select(aField:Property | aField.lower=1))]
			[let aProperty : Property = classStructures.getAssociations()->select(anAss : Association|anAss.memberEnd->exists(aMember : Property | aMember=aRefProperty)).memberEnd->select(aMember : Property | aMember<>aRefProperty)->asSequence()->first()]							
				[if (not aRefProperty.type.isSimpleType() and aRefProperty.type.oclIsTypeOf(Class) and aRefProperty.type.oclAsType(Class).isEntity())]
		==[aProperty = ownedProperty/]==
		==ownedProperty = [ownedProperty/]==
		==aProperty = [aProperty/]==
					[if (aProperty = ownedProperty)]
	if([refProperty.type.name.toLowerFirst()/] != null) {
						[if (aProperty.isNavigable())]
	    [refProperty.type.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/]([anEntity.name.toLowerFirst()/]);
						[/if]
						[let refAssociations : Sequence(Association) = refProperty.type.oclAsType(Class).getAllEntityParents()->including(refProperty.type.oclAsType(Class)).getAssociations()->select(anAss : Association|anAss.memberEnd->exists(aMember : Property | aMember=aProperty))->asSequence()]
							[if (refAssociations->notEmpty())]
								[let refField : Property = refAssociations.memberEnd->select(aMember : Property | aMember <> aProperty)->first()]
									[if (refField.upper >= 0 and refField.upper <= 1)]
										[if (refField.isNavigable())]
		[anEntity.name.toLowerFirst()/].set[refField.name.toUpperFirst()/]([refProperty.type.name.toLowerFirst()/]);
										[/if]
									[elseif (refField.isOrdered)]
		[anEntity.name.toLowerFirst()/].set[refField.name.toUpperFirst()/](Arrays.asList([refProperty.type.name.toLowerFirst()/]));
									[elseif (refField.isUnique)]
		[anEntity.name.toLowerFirst()/].set[refField.name.toUpperFirst()/](new HashSet(Arrays.asList([refProperty.type.name.toLowerFirst()/])));
									[elseif (not refField.isOrdered and not refField.isUnique)]
		[anEntity.name.toLowerFirst()/].set[refField.name.toUpperFirst()/](Arrays.asList([refProperty.type.name.toLowerFirst()/]));
									[/if]
								[/let]
							[else]
							[/if]								
						[/let]
						[if (aRefProperty.isNavigable())]
	} else {
		[anEntity.generateObjectProperty(aRefProperty, aProperty)/]	
						[/if]
	}
					[/if]								
				[else]
	[anEntity.generateObjectProperty(aRefProperty, aProperty)/]	
				[/if]
			[/let]
		[/for]
	[/let]
	[anEntity.name.toUpperFirst()/]DaoTest.get[anEntity.name.toUpperFirst()/]Dao().create([anEntity.name.toLowerFirst()/]);
	return [anEntity.name.toLowerFirst()/];
[comment][/for][/comment]
}
[/template]

[template public generateObjectProperty(anEntity : Class, refProperty : Property, ownedProperty : Property) ]
childIndex = childIndexMap.get([anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if].class.getName()); 
if(childIndex == null) {
	childIndex = Long.valueOf(index);
} else {
	childIndex = Long.valueOf(childIndex.longValue() + 1);
}
childIndexMap.put([anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if].class.getName(), childIndex);
	[if (ownedProperty.isNavigable())]
		[if (refProperty.upper = 1)]
[ownedProperty.type.name.toLowerFirst()/].set[refProperty.name.toUpperFirst()/](DaoTestUtil.create[refProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[ownedProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]));
[comment][anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](DaoTestUtil.create[refProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[ownedProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]));[/comment]
		[elseif (ownedProperty.isOrdered)]
[anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](Arrays.asList(DaoTestUtil.create[refProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[ownedProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/])));
		[elseif (ownedProperty.isUnique)]
[anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](new HashSet(Arrays.asList(DaoTestUtil.create[refProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[ownedProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]))));
		[elseif (not ownedProperty.isOrdered and not ownedProperty.isUnique)]
[anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](Arrays.asList(DaoTestUtil.create[refProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[ownedProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/])));
		[/if]
	[else]
		[if (refProperty.upper = 1)]
[ownedProperty.type.name.toLowerFirst()/].set[refProperty.name.toUpperFirst()/](DaoTestUtil.create[refProperty.type.name.toUpperFirst()/]Object(childIndex));
		[elseif (ownedProperty.isOrdered)]
[anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](Arrays.asList(DaoTestUtil.create[refProperty.type.name.toUpperFirst()/]Object(childIndex)));
		[elseif (ownedProperty.isUnique)]
[anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](new HashSet(Arrays.asList(DaoTestUtil.create[refProperty.type.name.toUpperFirst()/]Object(childIndex))));
		[elseif (not ownedProperty.isOrdered and not ownedProperty.isUnique)]
[anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](Arrays.asList(DaoTestUtil.create[refProperty.type.name.toUpperFirst()/]Object(childIndex)));
		[/if]
	[/if]
[/template]


